_value_ - тип переменной и ее значение
_place_ - место хранения значение
_variable_ - переменная, _place_ = стек
_pointer_ - указывает на _place_

## Borrow
Осмысление указателей (ссылок) в rust

В общем, в rust есть так называемые borrow
```rust
let y = &x;
```
это borrow переменной x

Типы так называемого Borrowing
+ *shared* (&T). Все shared - Copy и их может быть многа. Все значения по ним immutable, кстати
+ *mutable* (&mut T). Раст считает, что у такого borrow эксклюзивные права на владение (и отстаивает их). Они, кстати не освобождают память

Так вот, borrow не могут пересекаться, не все, но по сути не могут. Те код
```rust
let mut x;
x = 42;
let y = &x;
x = 43;
assert_eq!(*y, 42);
```
не скомпилится, тк 1-2-4 (&mut) это один borrow, а 1-2-3-5 (&) другой, ну и они не могут пересечься. Вот так как-то. 

*interior mutability* - переменные с таким свойством можно изменять через *shared borrow* 

## Lifetime

И смешновое про lifetime. 
Если lifetime двух переменных с один названием не пересекается (пока не понимаю как возможно такое пересечение), они могут существовать вместе. Это называется *shadowing* и на это cargo даже не бузит

Следующий код корректен и компилируется
```rust
let x = 3;
println!("{}", x);
let x = "hello";
println!("{}", x);
```

*borrow checker* - проверяет 'жива' ли переменная при ее использовании
## Box

Если очень хочется использовать 'cшные' указатели с типо безопасностью раста, вам к типу Box. Это, по сути, умный указатель. 

За исключением тривиальных типов, которые помечены Copy, все типы при операторе= и других разных передачах данных неявно выполняют move. 

