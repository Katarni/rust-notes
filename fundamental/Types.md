# Типочки

Самое самое базовое - это типы должны быть помещены на позицию, кратную байту (про длину, кратную байту не уверен). Есть еще, конечно выравнивание по машинному слову. 

Операции над не выравненными типами называются misaligned и много процев их рестриктит или рекомендует не использовать. Так как такое еще и не безопасно, раст пытается это фиксить

У всех типов есть свое выравнивание (*alignment*) и считается оно по размеру. У сложных типов (составных) выравнивание будет по наибольшей длине входящего в тип типа.

## layout

*layout* - то, по каким правилам типы (в том числе ваши), хранятся в памяти. Про типы раста мы пока говорить не будем, поговорим о пользовательских типах.

Rust предоставляет возможность выбрать *layout* для своей структуры 
```rust
#[repr(C)]
struct Foo {}
```
*листинг 1.0*

В нашем случае мы взяли *layout C*, но какими они бывают?

### transparent
Позволяет сделать *layout* точно таким же, как и *layout* поля структуры
**Этот *layout* применим только к структурам с один полем**

Это очень похоже на 
```rust
struct A {}

struct B(A) {}
```
*листинг 1.1*
*repr(transparent)* гарантирует аналогичный *layout*, в отличии от листинга 1.1 

### C
Этот *layout* повторяет все, что делает C со своими структурами. Этот *layout* **гарантирует**, что поля будут идти по порядку и оставляет *padding*-и между полями, чтобы соблюсти все выравнивания типов. Теперь к примерчику:

```rust
#[repr(C)]
struct A {
	a: bool,
	b: i32,
	c: i64,
}
```
*листинг 1.2*

Первым пойдет *bool*, его *alignment = 1 byte*. Далее пойдет i32, он *4-byte-aligned* => rust добавит 3 байта промежутка и мы получим 1 + 3 + 4 = 8. Для i64 нам даже не понадобятся промежутки и мы получим размер 1 + 3 + 4 + 8 = 16. Так как максимальный размер поля структуры = 8 => структура будет *8-byte-aligned*. 

Все просто и как в любимых плюсах, правда?)

### Rust
**Это дефолтный *layout* для всех структур**

Здесь все куда труднее и неприятнее. В общем, тут не гарантируется сохранение порядка полей структуры. Чуваки из раста подумали, подумали и решили, что они сортанут поля по уменьшению размера (ну скучно стало). Крч на листинге 1.2 не видно, но не сложно придумать пример, на котором будет профит в два раза (по *alignment*). 

> В книге, что я читаю, указывают: "Не гарантируется одинаковое размещение полей структур с одинаковыми полями одинаковых типов". Почему это не гарантируется я не особо понимаю, stable-sort существует давно, но вы все равно осторожней.

Промежутки между полями все еще будут, для избежания misaligned операций, но выигрыш реально приятный
### packed

Эта штука делает то же, что и в плюсах. Убирает все промежутки: вы получаете выигрыш по памяти и проигрыш по времени.

Есть еще *packed(N)*, тогда промежуток будет *= min(N, default)*

### align(N)
Делает **все** промежутки равными N. Все, больше ничего не делает.

### Применение

Layout можно совмещать (и они почти всегда совмещенные)
Так например \#\[repr(packed)] <=> \#\[repr(Rust, packed)]

*align* и *packed* - это, по сути, просто дополнения к настоящему *layout*: C и Rust.
Те можно писать
```rust
// C representation, alignment raised to 8
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
```
*листинг 1.3: да, он просто из документации*


## чуть-чуть про встроенные типочки

+ *tuple* - структура с полями в той же последовательности (и тех же типов), что и передаваемые типы.
+ *array* - последовательность инстансов переданного типа без промежутков.
+ *union* - все зависит от варианта.
+ *enum* - тоже как *union*, он ему еще надо хранить то, какой тип выбран.

